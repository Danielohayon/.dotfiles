# Kubectl FZF Shortcuts
# Interactive kubectl commands using fzf

# Main menu - list all kubectl shortcuts
ku() {
    local cmd
    cmd=$(cat <<'EOF' | fzf --height=50% --reverse --prompt="kubectl shortcut: " --with-nth=1.. --delimiter='\t'
kpod	Describe a pod
klogs	View pod logs
klogsf	Follow pod logs (live tail)
klogsp	Logs from previous crashed container
klogst	Logs with timestamps
klogsd	Tail logs from all pods in a deployment
klogsc	Select container for logs (multi-container)
kexec	Exec into a pod
kpoddel	Delete a single pod
ksvc	Describe a service
kdeploy	Describe a deployment
kevents	Get events for a pod
kns	Switch namespace
kctx	Switch context (cluster)
kpf	Port-forward to a pod
kbad	Find pods in bad states
kevall	All events sorted by time
kevwarn	Warning events only
ktrouble	Troubleshoot pod (describe + events + logs)
ktop	Pod resource usage
ktopn	Node resource usage
ktopc	Pods sorted by CPU
ktopm	Pods sorted by memory
ksecret	View decoded secret
kcm	View configmap
krestart	Rolling restart deployment
krollback	Rollback deployment
krollout	Watch rollout status
kscale	Scale deployment
kyaml	Get YAML of any resource
kdebug	Run debug pod (curl/dig)
kcp	Copy file from pod
kpodip	Get pod IP
kpodnode	Get node where pod runs
knodepods	List pods on a node
kwatch	Watch pods (auto-refresh)
kimage	Find pods by image name
kall	Overview (pods + svc + deploy)
kdel	Delete resources (multi-select, by type)
kdela	Delete from ALL types in one view (multi-select)
gke	Switch GKE cluster (zone -> cluster)
gkea	Switch GKE cluster (all in one view)
gar-browse	Browse Artifact Registry (repos -> images -> tags)
gar-images	List images in a repository
gar-tags	List tags for an image
gar-find	Search for tag/digest in image
kpodimages	Show images used by pods
kfindimage	Find pods by image name (all namespaces)
kcheckimage	Compare deployment image vs registry
EOF
    )
    cmd=$(echo "$cmd" | awk -F'\t' '{print $1}')
    if [[ -n "$cmd" ]]; then
        # Execute the selected command
        eval "$cmd"
    fi
}

# Helper: select a pod with full info displayed, returns pod name
_kfzf_pod() {
    kubectl get pods "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Select pod: " | awk '{print $1}'
}

# Helper: select a service with full info displayed
_kfzf_svc() {
    kubectl get svc "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Select service: " | awk '{print $1}'
}

# Helper: select a deployment with full info displayed
_kfzf_deploy() {
    kubectl get deployments "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Select deployment: " | awk '{print $1}'
}

# Describe a pod interactively
# Lists pods via fzf, then shows describe output in less (starting from bottom)
kpod() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl describe pod "$pod" "$@" | less -R +G
    fi
}

# View pod logs interactively
klogs() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl logs "$pod" "$@" | less -R +G
    fi
}

# Follow pod logs interactively (live tail)
klogsf() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl logs -f "$pod" "$@"
    fi
}

# Exec into a pod interactively
kexec() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl exec -it "$pod" "$@" -- /bin/bash || kubectl exec -it "$pod" "$@" -- /bin/sh
    fi
}

# Delete a pod interactively
kpoddel() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        echo "Deleting pod: $pod"
        kubectl delete pod "$pod" "$@"
    fi
}

# Describe a service interactively
ksvc() {
    local svc
    svc=$(_kfzf_svc "$@")
    if [[ -n "$svc" ]]; then
        kubectl describe svc "$svc" "$@" | less -R +G
    fi
}

# Describe a deployment interactively
kdeploy() {
    local deploy
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        kubectl describe deployment "$deploy" "$@" | less -R +G
    fi
}

# Get events for a pod interactively
kevents() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl get events --field-selector involvedObject.name="$pod" "$@" | less -R +G
    fi
}

# Switch namespace interactively
kns() {
    local ns
    ns=$(kubectl get namespaces | fzf --height=40% --reverse --header-lines=1 --prompt="Select namespace: " | awk '{print $1}')
    if [[ -n "$ns" ]]; then
        kubectl config set-context --current --namespace="$ns"
        echo "Switched to namespace: $ns"
    fi
}

# Switch context (cluster) interactively
kctx() {
    local ctx
    ctx=$(kubectl config get-contexts | fzf --height=40% --reverse --header-lines=1 --prompt="Select context: " | awk '{print $1}')
    # Handle the '*' marker for current context
    [[ "$ctx" == "*" ]] && ctx=$(kubectl config get-contexts | fzf --height=40% --reverse --header-lines=1 --prompt="Select context: " | awk '{print $2}')
    if [[ -n "$ctx" && "$ctx" != "*" ]]; then
        kubectl config use-context "$ctx"
    fi
}

# Port-forward to a pod interactively
kpf() {
    local pod port
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        echo -n "Enter port (local:remote, e.g., 8080:80): "
        read port
        kubectl port-forward "$pod" "$port" "$@"
    fi
}

# ============================================
# Logs helpers
# ============================================

# View logs from previous crashed container
klogsp() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl logs "$pod" --previous "$@" | less -R +G
    fi
}

# View logs with timestamps
klogst() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl logs "$pod" --timestamps "$@" | less -R +G
    fi
}

# Tail logs from all pods of a deployment
klogsd() {
    local deploy
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        kubectl logs -f "deployment/$deploy" --all-containers=true "$@"
    fi
}

# Select container in multi-container pod for logs
klogsc() {
    local pod container
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        container=$(kubectl get pod "$pod" -o jsonpath='{.spec.containers[*].name}' "$@" | tr ' ' '\n' | fzf --height=40% --reverse --prompt="Select container: ")
        if [[ -n "$container" ]]; then
            kubectl logs "$pod" -c "$container" "$@" | less -R +G
        fi
    fi
}

# ============================================
# Troubleshooting
# ============================================

# Find pods in bad states (CrashLoopBackOff, Error, ImagePullBackOff, Pending)
kbad() {
    echo "=== Pods in bad states ==="
    kubectl get pods --all-namespaces "$@" | grep -E '(CrashLoopBackOff|Error|ImagePullBackOff|Pending|Init:|ErrImagePull|CreateContainerConfigError)' | less -R
}

# Get all events sorted by time (most recent last)
kevall() {
    kubectl get events --sort-by='.lastTimestamp' "$@" | less -R +G
}

# Show recent warning events only
kevwarn() {
    kubectl get events --field-selector type=Warning --sort-by='.lastTimestamp' "$@" | less -R +G
}

# Quick pod troubleshoot: shows describe + events + logs in one view
ktrouble() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        {
            echo "=============== DESCRIBE ==============="
            kubectl describe pod "$pod" "$@"
            echo -e "\n=============== EVENTS ==============="
            kubectl get events --field-selector involvedObject.name="$pod" "$@"
            echo -e "\n=============== LOGS (last 50 lines) ==============="
            kubectl logs "$pod" --tail=50 "$@" 2>/dev/null || echo "No logs available"
        } | less -R +G
    fi
}

# ============================================
# Resource usage
# ============================================

# Show pod resource usage (requires metrics-server)
ktop() {
    kubectl top pods "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Pod resources: "
}

# Show node resource usage
ktopn() {
    kubectl top nodes "$@"
}

# Show pods sorted by CPU usage
ktopc() {
    kubectl top pods "$@" --sort-by=cpu
}

# Show pods sorted by memory usage
ktopm() {
    kubectl top pods "$@" --sort-by=memory
}

# ============================================
# Secrets and ConfigMaps
# ============================================

# View decoded secret interactively
ksecret() {
    local secret key
    secret=$(kubectl get secrets "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Select secret: " | awk '{print $1}')
    if [[ -n "$secret" ]]; then
        echo "=== Secret: $secret ==="
        kubectl get secret "$secret" -o json "$@" | jq -r '.data | to_entries[] | "\(.key): \(.value | @base64d)"'
    fi
}

# View configmap interactively
kcm() {
    local cm
    cm=$(kubectl get configmaps "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Select configmap: " | awk '{print $1}')
    if [[ -n "$cm" ]]; then
        kubectl describe configmap "$cm" "$@" | less -R +G
    fi
}

# ============================================
# Deployment operations
# ============================================

# Restart a deployment (rolling restart)
krestart() {
    local deploy
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        echo "Restarting deployment: $deploy"
        kubectl rollout restart deployment "$deploy" "$@"
    fi
}

# Rollback a deployment
krollback() {
    local deploy
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        echo "Rolling back deployment: $deploy"
        kubectl rollout undo deployment "$deploy" "$@"
    fi
}

# Watch rollout status
krollout() {
    local deploy
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        kubectl rollout status deployment "$deploy" "$@"
    fi
}

# Scale a deployment interactively
kscale() {
    local deploy replicas
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        echo -n "Enter replica count: "
        read replicas
        kubectl scale deployment "$deploy" --replicas="$replicas" "$@"
    fi
}

# ============================================
# Quick access
# ============================================

# Get YAML of any resource (for backup/editing)
kyaml() {
    local resource item
    resource=$(echo -e "pod\ndeployment\nservice\nconfigmap\nsecret\ningress\npvc\nstatefulset\ndaemonset\njob\ncronjob" | fzf --height=40% --reverse --prompt="Select resource type: ")
    if [[ -n "$resource" ]]; then
        item=$(kubectl get "$resource" "$@" | fzf --height=40% --reverse --header-lines=1 --prompt="Select $resource: " | awk '{print $1}')
        if [[ -n "$item" ]]; then
            kubectl get "$resource" "$item" -o yaml "$@" | less -R
        fi
    fi
}

# Run a debug pod with common tools (curl, dig, etc)
kdebug() {
    local ns_flag=""
    [[ "$*" == *"-n"* ]] && ns_flag="$@"
    echo "Starting debug pod (alpine with curl, dig, wget)..."
    kubectl run debug-pod-$RANDOM --rm -it --image=alpine/curl --restart=Never $ns_flag -- /bin/sh
}

# Copy file from pod interactively
kcp() {
    local pod src dest
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        echo -n "Source path in pod: "
        read src
        echo -n "Local destination: "
        read dest
        kubectl cp "$pod:$src" "$dest" "$@"
    fi
}

# Get pod IP
kpodip() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl get pod "$pod" -o jsonpath='{.status.podIP}' "$@"
        echo
    fi
}

# Show which node a pod is on
kpodnode() {
    local pod
    pod=$(_kfzf_pod "$@")
    if [[ -n "$pod" ]]; then
        kubectl get pod "$pod" -o jsonpath='{.spec.nodeName}' "$@"
        echo
    fi
}

# Show all pods on a specific node
knodepods() {
    local node
    node=$(kubectl get nodes | fzf --height=40% --reverse --header-lines=1 --prompt="Select node: " | awk '{print $1}')
    if [[ -n "$node" ]]; then
        kubectl get pods --all-namespaces --field-selector spec.nodeName="$node" "$@"
    fi
}

# Watch pods (auto-refresh)
kwatch() {
    watch -n 2 "kubectl get pods $*"
}

# Find pods by image name
kimage() {
    local image
    echo -n "Image name (partial match): "
    read image
    kubectl get pods -o jsonpath="{range .items[*]}{.metadata.name}{'\t'}{.spec.containers[*].image}{'\n'}{end}" "$@" | grep -i "$image"
}

# Quick get all: pods, svc, deploy in one view
kall() {
    {
        echo "=== PODS ==="
        kubectl get pods "$@"
        echo -e "\n=== SERVICES ==="
        kubectl get svc "$@"
        echo -e "\n=== DEPLOYMENTS ==="
        kubectl get deployments "$@"
    } | less -R
}

# Delete any resource type with multi-select
# Use Tab to mark multiple items, Enter to confirm
kdel() {
    local resource items
    resource=$(echo -e "pod\ndeployment\nservice\nconfigmap\nsecret\ningress\npvc\nstatefulset\ndaemonset\njob\ncronjob\nreplicaset" | fzf --height=40% --reverse --prompt="Select resource type: ")
    if [[ -n "$resource" ]]; then
        echo "Use Tab to select multiple, Enter to confirm deletion"
        items=$(kubectl get "$resource" "$@" | fzf --height=50% --reverse --header-lines=1 --multi --prompt="Select $resource(s) to DELETE: " | awk '{print $1}')
        if [[ -n "$items" ]]; then
            echo "Will delete the following $resource(s):"
            echo "$items"
            echo -n "Confirm? (y/N): "
            read confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                echo "$items" | xargs -I {} kubectl delete "$resource" {} "$@"
            else
                echo "Cancelled."
            fi
        fi
    fi
}

# Delete from all resource types in one view (multi-select)
# Shows pods, deployments, services, jobs, etc. all together
kdela() {
    local selections
    echo "Fetching all resources..."

    # Gather all resources with TYPE prefix for identification
    selections=$(
        {
            kubectl get pods --no-headers "$@" 2>/dev/null | awk '{print "pod\t" $0}'
            kubectl get deployments --no-headers "$@" 2>/dev/null | awk '{print "deploy\t" $0}'
            kubectl get services --no-headers "$@" 2>/dev/null | awk '{print "svc\t" $0}'
            kubectl get jobs --no-headers "$@" 2>/dev/null | awk '{print "job\t" $0}'
            kubectl get cronjobs --no-headers "$@" 2>/dev/null | awk '{print "cronjob\t" $0}'
            kubectl get configmaps --no-headers "$@" 2>/dev/null | awk '{print "cm\t" $0}'
            kubectl get secrets --no-headers "$@" 2>/dev/null | awk '{print "secret\t" $0}'
            kubectl get statefulsets --no-headers "$@" 2>/dev/null | awk '{print "sts\t" $0}'
            kubectl get daemonsets --no-headers "$@" 2>/dev/null | awk '{print "ds\t" $0}'
            kubectl get replicasets --no-headers "$@" 2>/dev/null | awk '{print "rs\t" $0}'
            kubectl get pvc --no-headers "$@" 2>/dev/null | awk '{print "pvc\t" $0}'
            kubectl get ingress --no-headers "$@" 2>/dev/null | awk '{print "ing\t" $0}'
        } | fzf --height=60% --reverse --multi --prompt="Select resource(s) to DELETE (Tab=select): " \
              --header="TYPE      NAME                                      STATUS" \
              --preview-window=hidden
    )

    if [[ -n "$selections" ]]; then
        echo -e "\nWill delete:"
        echo "$selections" | while read -r line; do
            local type=$(echo "$line" | awk '{print $1}')
            local name=$(echo "$line" | awk '{print $2}')
            echo "  $type/$name"
        done

        echo -n -e "\nConfirm? (y/N): "
        read confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "$selections" | while read -r line; do
                local type=$(echo "$line" | awk '{print $1}')
                local name=$(echo "$line" | awk '{print $2}')
                echo "Deleting $type/$name..."
                kubectl delete "$type" "$name" "$@"
            done
            echo "Done."
        else
            echo "Cancelled."
        fi
    fi
}

# ============================================
# GKE Cluster switching
# ============================================

# Switch GKE cluster interactively (zone -> cluster)
gke() {
    local project zone cluster

    # Get current project
    project=$(gcloud config get-value project 2>/dev/null)
    echo "Project: $project"

    # List zones that have clusters
    echo "Fetching available zones..."
    zone=$(gcloud container clusters list --project "$project" --format="value(location)" 2>/dev/null | sort -u | fzf --height=40% --reverse --prompt="Select zone: ")
    [[ -z "$zone" ]] && return

    # List clusters in that zone
    echo "Fetching clusters in $zone..."
    cluster=$(gcloud container clusters list --project "$project" --filter="location:$zone" --format="table(name,status,currentNodeCount)" 2>/dev/null | fzf --height=40% --reverse --header-lines=1 --prompt="Select cluster: " | awk '{print $1}')
    [[ -z "$cluster" ]] && return

    echo "Switching to cluster: $cluster (zone: $zone)"
    gcloud container clusters get-credentials "$cluster" --zone "$zone" --project "$project"
}

# Switch GKE cluster - all clusters in one view
gkea() {
    local project selection cluster zone

    # Get current project
    project=$(gcloud config get-value project 2>/dev/null)
    echo "Project: $project"

    # List all clusters with zone info
    echo "Fetching all clusters..."
    selection=$(gcloud container clusters list --project "$project" --format="table(name,location,status,currentNodeCount)" 2>/dev/null | fzf --height=50% --reverse --header-lines=1 --prompt="Select cluster: ")
    [[ -z "$selection" ]] && return

    cluster=$(echo "$selection" | awk '{print $1}')
    zone=$(echo "$selection" | awk '{print $2}')

    echo "Switching to cluster: $cluster (zone: $zone)"
    gcloud container clusters get-credentials "$cluster" --zone "$zone" --project "$project"
}

# ============================================
# Container Registry helpers (GCP Artifact Registry)
# ============================================

# Set default artifact registry path (customize this)
: ${GAR_DEFAULT_REPO:=""}

# List images in a GCP Artifact Registry repository
# Usage: gar-images [repository-path]
gar-images() {
    local repo="${1:-$GAR_DEFAULT_REPO}"
    if [[ -z "$repo" ]]; then
        echo "Usage: gar-images <repository-path>"
        echo "Example: gar-images us-central1-docker.pkg.dev/my-project/my-repo"
        echo "Or set GAR_DEFAULT_REPO in your shell config"
        return 1
    fi
    gcloud artifacts docker images list "$repo" 2>/dev/null | fzf --height=50% --reverse --header-lines=1 --prompt="Images: "
}

# List tags for an image in Artifact Registry
# Usage: gar-tags <image-path>
gar-tags() {
    local image="${1:-}"
    if [[ -z "$image" ]]; then
        echo "Usage: gar-tags <image-path>"
        echo "Example: gar-tags us-central1-docker.pkg.dev/my-project/my-repo/my-image"
        return 1
    fi
    gcloud artifacts docker tags list "$image" 2>/dev/null | fzf --height=50% --reverse --header-lines=1 --prompt="Tags: "
}

# Search for a tag/digest across an image
# Usage: gar-find <image-path> <search-term>
gar-find() {
    local image="${1:-}"
    local search="${2:-}"
    if [[ -z "$image" || -z "$search" ]]; then
        echo "Usage: gar-find <image-path> <search-term>"
        echo "Example: gar-find us-central1-docker.pkg.dev/my-project/my-repo/my-image 5a3fd97"
        return 1
    fi
    gcloud artifacts docker tags list "$image" 2>/dev/null | grep -i "$search"
}

# Interactive: browse repos -> images -> tags
gar-browse() {
    local project region repo image tag

    # Get current project or let user input
    project=$(gcloud config get-value project 2>/dev/null)
    echo "Project: $project"

    # List repositories
    echo "Fetching repositories..."
    repo=$(gcloud artifacts repositories list --format="value(name,format)" 2>/dev/null | fzf --height=40% --reverse --prompt="Select repository: " | awk '{print $1}')
    [[ -z "$repo" ]] && return

    # Get region from repo
    region=$(gcloud artifacts repositories describe "$repo" --format="value(name)" 2>/dev/null | cut -d'/' -f4)

    local repo_path="${region}-docker.pkg.dev/${project}/${repo}"
    echo "Repository: $repo_path"

    # List images
    echo "Fetching images..."
    image=$(gcloud artifacts docker images list "$repo_path" --format="table(package)" 2>/dev/null | fzf --height=40% --reverse --header-lines=1 --prompt="Select image: " | awk '{print $1}')
    [[ -z "$image" ]] && return

    # List tags
    echo "Fetching tags for $image..."
    tag=$(gcloud artifacts docker tags list "$image" 2>/dev/null | fzf --height=50% --reverse --header-lines=1 --prompt="Select tag: ")

    if [[ -n "$tag" ]]; then
        echo -e "\nSelected: $tag"
        echo -n "Copy to clipboard? (y/N): "
        read copy
        if [[ "$copy" =~ ^[Yy]$ ]]; then
            echo "$tag" | awk '{print $1}' | tr -d '\n' | pbcopy
            echo "Copied to clipboard!"
        fi
    fi
}

# Show what images pods are currently using
kpodimages() {
    echo "=== Pod Images in current namespace ==="
    kubectl get pods -o jsonpath="{range .items[*]}{.metadata.name}{'\t'}{range .spec.containers[*]}{.image}{', '}{end}{'\n'}{end}" "$@" | column -t -s $'\t'
}

# Find pods running a specific image (partial match)
kfindimage() {
    local search="$1"
    if [[ -z "$search" ]]; then
        echo -n "Image name (partial match): "
        read search
    fi
    echo "=== Pods using image matching '$search' ==="
    kubectl get pods -o jsonpath="{range .items[*]}{.metadata.name}{'\t'}{.metadata.namespace}{'\t'}{range .spec.containers[*]}{.image}{' '}{end}{'\n'}{end}" --all-namespaces 2>/dev/null | grep -i "$search" | column -t -s $'\t'
}

# Compare image in deployment vs what's in registry
kcheckimage() {
    local deploy image current_tag
    deploy=$(_kfzf_deploy "$@")
    if [[ -n "$deploy" ]]; then
        image=$(kubectl get deployment "$deploy" -o jsonpath='{.spec.template.spec.containers[0].image}' "$@")
        echo "Current image: $image"
        echo ""
        echo "Checking registry for latest tags..."
        # Extract base image path (without tag)
        local base_image=$(echo "$image" | cut -d: -f1)
        gcloud artifacts docker tags list "$base_image" 2>/dev/null | head -20
    fi
}
